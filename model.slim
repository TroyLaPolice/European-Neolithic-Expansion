initialize()
{
	initializeSLiMModelType("nonWF");
	initializeSLiMOptions(dimensionality="xy", periodicity="");
	
	// ---------------------------------------------------
	//  PARAMETERS --> Initialize Constant Params
	// ---------------------------------------------------
	//SET WORKING DIRECTORY AND CUSTOM MAP NAME IF DESIRED
	if (!exists("wd"))
		defineConstant("wd", "/home/tml5905/Documents/CoralPopulationSimulation");
	if (!exists("custom_map_filename"))
		defineConstant("custom_map_filename", 0); // Parameter = file name of map (as string) if user wants to use their own map and override the built in maps, else == 0
	if (!exists("output_name"))
		defineConstant("output_name", "out"); // To run default names make an empty string
	
	// Carrying Capacities and Pop Sizes:
	// ***********************************
	if (!exists("DS"))
		defineConstant("DS", 1); // Down scale the simulation ( Must be >= 1)
	if (!exists("SN"))
		defineConstant("SN", integerDiv(300, DS)); // Starting number of individuals
	if (!exists("cervicornisK"))
		defineConstant("cervicornisK", 0.064 / DS); // carrying capacity for cervicornis (ENTER IN INDIVIDUALS PER KM2) for density dependent scaling 
	if (!exists("palmataK"))
		defineConstant("palmataK", 0.128 / DS); // carrying capacity for palmata (ENTER IN INDIVIDUALS PER KM2) for density dependent scaling
	if (!exists("initial_ratio"))
		defineConstant("initial_ratio", 0.5); // ratio of cervicornis:palmata
	
	// Movement and interaction and competition:
	// ***********************************
	if (!exists("SDX"))
		defineConstant("SDX", 5); // Movement standard diviation (sigma) for distribution of distances sampled from in the x direction (ENTER IN KILOMETERS)
	if (!exists("SDY"))
		defineConstant("SDY", 5); // Movement standard diviation (sigma) for distribution of distances sampled from in the y direction (ENTER IN KILOMETERS)
	
	// Mating rate params:
	// ***********************************
	if (!exists("settle_cer"))
		defineConstant("settle_cer", 0.022308); // Settlement for cervicornis X cervicornis cross
	if (!exists("settle_pal"))
		defineConstant("settle_pal", 0.0351); // Settlement for palmata X palmata cross
	if (!exists("settle_pro"))
		defineConstant("settle_pro", 0.07215); // Settlement for a prolifera
	if (!exists("MD"))
		defineConstant("MD", 5); // Mating distance (ENTER IN KILOMETERS)
	if (!exists("cer_cer"))
		defineConstant("cer_cer", 0.525); // Mating pref for cervicornis X cervicornis
	if (!exists("pal_pal"))
		defineConstant("pal_pal", 0.705); // Mating pref for palmata X palmata
	if (!exists("pro_pro"))
		defineConstant("pro_pro", 0.705); // Mating pref for palmata X palmata
	
	// ---------------------------------------------------
	// RUN TIME PREFERENCE PARAMETERS
	// ---------------------------------------------------
	// Determine Coloring Schemes:
	// ***********************************	
	defineConstant("Color_scheme", 1); // Parameter of 0 = Genomic Coloring, 1 = Phenotypic Coloring
	
	// Map Prefs: 
	// ***********************************	
	if (!exists("map_style"))
		defineConstant("map_style", 1); // 0 = simple, 1 = Laughing Bird Caye, 6 = custom map
	defineConstant("file_extention", ".png");
	defineConstant("simple", wd + "/simple.png"); // File Path to Map Image
	defineConstant("LaughingBirdCaye", wd + "/laughing_bird_caye.png"); // File Path to Map Image
	defineConstant("custom_map", wd + custom_map_filename); // File Path to Map Image
	
	// If using provided EEA maps, length and width for map style images should be kept at a 1 to 1 aspect ratio (square) to avoid distortion
	if (!exists("map_size_length"))
		defineConstant("map_size_length", 12.964);
	if (!exists("map_size_width"))
		defineConstant("map_size_width", 8.96);
	
	// Map citation: https://www.eea.europa.eu/data-and-maps/figures/elevation-map-of-europe
	// ----------------------------------------------------
	//  GENETIC COMPONENT --> Initialize Genomic Elements
	// ----------------------------------------------------
	initializeMutationType("m1", 0.5, "f", 0.0); // Tag palmata ancestry
	m1.convertToSubstitution = F;
	initializeGenomicElementType("g1", m1, 1.0);
	initializeGenomicElement(g1, 0, 2886);
	initializeMutationRate(0.0);
	rates = c(0.01, 0.5, 0.01, 0.5, 0.01, 0.5, 0.01, 0.5, 0.01, 0.5, 0.01, 0.5, 0.01, 0.5, 0.01, 0.5, 0.01, 0.5, 0.01, 0.5, 0.01, 0.5, 0.01, 0.5, 0.01, 0.5, 0.01, 0.5, 0.01, 0.5, 0.01, 0.5, 0.01, 0.5, 0.01, 0.5, 0.01, 0.5, 0.01, 0.5, 0.01, 0.5, 0.01);
	ends = c(247, 248, 491, 492, 692, 693, 884, 885, 1066, 1067, 1238, 1239, 1398, 1399, 1545, 1546, 1686, 1687, 1822, 1823, 1957, 1958, 2090, 2091, 2205, 2206, 2312, 2313, 2413, 2414, 2503, 2504, 2583, 2584, 2660, 2661, 2724, 2725, 2787, 2788, 2835, 2836, 2886);
	initializeRecombinationRate(rates, ends);
	
	// ---------------------------------------------------
	//  INTERACTIONS --> Interaction Initialization
	// ---------------------------------------------------
	// spatial mate choice
	initializeInteractionType(2, "xy", reciprocal=T, maxDistance=MD);
}

1 early()
{
	sim.addSubpop("p1", SN);
}

2: first()
{
	// look for mates
	i2.evaluate(p1);
}

reproduction()
{
	// ---------------------------------------------------
	//  MATING --> Individuals mate with those close by
	// ---------------------------------------------------
	
	
	// choose nearest neighbor as a mate, within the max distance
	mates = i2.nearestInteractingNeighbors(individual, p1.individuals.length());
	if (mates.size()) // Runs if there are possible mates near by
	{
		// Sets up a vector that checks if the individuals in the surrounding area are of like phenotype (i.e. if their z params are the same)
		mates_similarity_bool = mates.z == individual.z;
		mates_similarity = asFloat(mates_similarity_bool);
		
		// Generates a vector of probabilites of the individual mating with a particular mate given their phenotype
		
		if (individual.z == 0) // individual == cervicornis
		{
			mates_similarity[mates_similarity_bool == T] = cer_cer;
			mates_similarity[mates_similarity_bool == F] = (1 - cer_cer);
		}
		else if (individual.z == 1) // individual == palmata
		{
			mates_similarity[mates_similarity_bool == T] = pal_pal;
			mates_similarity[mates_similarity_bool == F] = (1 - pal_pal);
		}
		else if (individual.z == 2) // individual == prolifera
		{
			mates_similarity[mates_similarity_bool == T] = 0.5;
			mates_similarity[mates_similarity_bool == F] = 0.5;
		}
		
		if (sum(mates_similarity) != 0)
		{
			// Samples an individual in the population based on the assortative mating probabilities. 
			mate = sample(mates, 1, weights=mates_similarity);
			
			// select proper settlement rate
			
			if (individual.z == 0)
			{
				if (mate.z == 0)
					settle = settle_cer;
				else if (mate.z == 1)
					settle = settle_pro;
				else if (mate.z == 2)
					settle = settle_cer;
			}
			
			else if (individual.z == 1)
			{
				if (mate.z == 0)
					settle = settle_pro;
				else if (mate.z == 1)
					settle = settle_pal;
				else if (mate.z == 2)
					settle = settle_pal;
			}
			else if (individual.z == 2)
			{
				if (mate.z == 0)
					settle = settle_cer;
				else if (mate.z == 1)
					settle = settle_pal;
				else if (mate.z == 2)
					settle = settle_pro;
			}
			for (i in seqLen(rpois(1, settle)))
			{
				// Only runs if a mate is nearby
				if (mate.size())
				{
					// Generates an offspring
					offspring = subpop.addCrossed(individual, mate);
					
					// -----------------------
					// Color Based on Genotype
					// -----------------------
					value = offspring.countOfMutationsOfType(m1) / (sim.chromosome.lastPosition * 2);
					offspring.color = rgb2color(hsv2rgb(c(0.6, 1.0, value)));
					
					// Define z param in offspring (phenotype, 0 = cervicornis, 1 = palmata, 2 == prolifera)
					offspring.z = 0;
					
					// If both parents are cervicornis the child is a cervicornis
					
					// If both parents are palmata the child is a palmata
					if (individual.z == 1 & mate.z == 1)
						offspring.z = 1;
						
					// If one parent is palmata and the other is cervicornis the child is a prolifera
					else if (individual.z == 0 & mate.z == 1)
						offspring.z = 2;
					else if (individual.z == 1 & mate.z == 0)
						offspring.z = 2;
						
					// If one both parents are prolifera the child is prolifera
					else if (individual.z == 2 & mate.z == 2)
						offspring.z = 2;
						
					// BACKCROSSES:
					// ------------
					
					// If one is a prolifera and the other is palmata the individual is palmata
					else if (individual.z == 2 & mate.z == 1)
						offspring.z = 1;
					else if (individual.z == 1 & mate.z == 2)
						offspring.z = 1;
						
					// If one is a prolifera and the other is cervicornis the individual is palmata
					else if (individual.z == 2 & mate.z == 0)
						offspring.z = 0;
					else if (individual.z == 0 & mate.z == 2)
						offspring.z = 0;
						
						
					if (Color_scheme == 1)
					{
						// -----------------------
						// Color Based on Behavior
						// -----------------------
						// Add color to represent phenotype
						if (offspring.z == 0) // cervicornis
							offspring.color = "red"; //cervicornis = red
						else if (offspring.z == 1) // palmata
							offspring.color = "blue"; //palmata = blue
						else if (offspring.z == 2) // prolifera
							offspring.color = "green"; // prolifera = green
					}
					
					// Next we set the position of the offspring at the parent's location
					pos = individual.spatialPosition;
					offspring.setSpatialPosition(pos);
					
					// ---------------------------------------------------
					//  MOVEMENT --> How larvae disperse
					// ---------------------------------------------------
					for (ind in p1.individuals)
					{
						// How far individuals diffuse away from their location
						do
						{
							coordinate_matrix = rmvnorm(1, c(0, 0), matrix(c(SDX^2, 0, 0, SDY^2), nrow=2));
							coordinates = c(coordinate_matrix[0], coordinate_matrix[1]);
							
							// Next we can reset the position
							newPos = ind.spatialPosition + coordinates;
						}
						while (!p1.pointInBounds(newPos) | p1.spatialMapValue("map_object", newPos) == 0.0);
						ind.setSpatialPosition(newPos);
					}
				}
			}
		}
	}
}

1 early()
{
	// Check user input for what style map
	if (map_style == 0)
		mapImage = Image(simple); //simple
	else if (map_style == 1)
		mapImage = Image(LaughingBirdCaye); //caye
	else if (map_style == 2)
		mapImage = Image(custom_map); //custom
	
	// Set up map
	p1.setSpatialBounds(c(0.0, 0.0, map_size_width, map_size_length));
	p1.defineSpatialMap("map_object", "xy", 1.0 - mapImage.floatK, valueRange=c(0.0, 1.0), colors=c("#ffffff", "#000000"));
	
	// place individuals on the map
	for (ind in p1.individuals)
	{
		do
			newPos = c(runif(1, 0, map_size_width), runif(1, 0, map_size_length));
		while (!p1.pointInBounds(newPos) | p1.spatialMapValue("map_object", newPos) == 0.0);
		ind.setSpatialPosition(newPos);
		ind.z = 0;
	}
	
	// Define z param in offspring (phenotype, 0 = cervicornis, 1 = palmata, 2 = prolifera)
		palmata_inds = p1.sampleIndividuals(asInteger(initial_ratio*SN));
		palmata_inds.z = 1;
		
	// Tag genomic ancestry of palmata with marker mutations (m1)
	// Each marker mutation represents 1Mb
	indpalmata = p1.individuals[p1.individuals.z == 1];
	indpalmata.genomes.addNewMutation(m1, 0.0, 0:2886);
	
	// Add color to represent phenotype
	for (i in p1.individuals)
	{
		// -----------------------
		// Color Based on Phenotype
		// -----------------------
		value = i.countOfMutationsOfType(m1) / (sim.chromosome.lastPosition * 2);
		i.color = rgb2color(hsv2rgb(c(0.6, 1.0, value)));
		if (Color_scheme == 1)
		{
			// -----------------------
			// Color Based on Behavior
			// -----------------------
			// Add color to represent phenotype
			if (i.z == 0) // cervicornis
				i.color = "red"; //cervicornis = red
			else if (i.z == 1) // palmata
				i.color = "blue"; //palmata = blue
			else if (i.z == 2) // prolifera
				i.color = "green"; // prolifera = green
		}
	}
}

1 early()
{
	// log runtime params
	param_string = paste(SN, cervicornisK, palmataK, SDX, SDY);
	
	// File headings
	param_heading = paste("SN cervicornisK palmataK SDX SDY");
	
	// Runtime params - write to file
	output_runtime_file_name = ("/sim_runtime_params_" + output_name + ".txt");
	writeFile(wd + output_runtime_file_name, param_heading, append=T);
	writeFile(wd + output_runtime_file_name, param_string, append=T);
	
	// Population stats headers - write to file
	stats_header_string = paste("Year", "PopulationSize", "Total_palmata", "Total_cervicornis", "Total_prolifera", "Ratio_palmata_to_cervicornis", "palmata_Ancestry_palmata", "palmata_Ancestry_cervicornis", sep=",");
	output_stats_file_name = ("/sim_pop_stats_per_year_" + output_name + ".txt");
	writeFile(wd + output_stats_file_name, stats_header_string, append=T);
}

1:6000 late()
{
	// provide feedback on progress for command line users
	year_counter = paste("Simulation Year: ", sim.cycle);
	print(year_counter);
	
	// define vector of palmata, vector of cervicornis, vector of prolifera
	palmata = p1.individuals[p1.individuals.z == 1];
	cervicornis = p1.individuals[p1.individuals.z == 0];
	prolifera = p1.individuals[p1.individuals.z == 2];
	
	// calculate num palmata
	num_palmata = length(palmata);
	
	//calculate num cervicornis
	num_cervicornis = length(cervicornis);
	
	//calculate num prolifera
	num_prolifera = length(prolifera);
	
	// calculate the ratio of palmata in the total population to file
	ratio = (num_palmata / num_cervicornis);
	
	// calculate population size statistics
	pop_size = p1.individuals.length();
	
	// calculate the palmata ancestry in all palmata
	if (length(palmata) != 0)
		cervicornis_ancestry_palmata = (1 - (mean(palmata.countOfMutationsOfType(m1) / (sim.chromosome.lastPosition * 2 + 2))));
	else
		palmata_ancestry_palmata = 0.0;
	
	// calculate the palmata ancestry in all cervicornis
	if (length(cervicornis) != 0)
		palmata_ancestry_cervicornis = mean(cervicornis.countOfMutationsOfType(m1) / (sim.chromosome.lastPosition * 2 + 2));
	else
		palmata_ancestry_cervicornis = 0.0;
	
	// write outputs
	output_string = paste(sim.cycle, pop_size, num_palmata, num_cervicornis, num_prolifera, ratio, cervicornis_ancestry_palmata, palmata_ancestry_cervicornis, sep=",");
	output_stats_file_name = ("/sim_pop_stats_per_year_" + output_name + ".txt");
	writeFile(wd + output_stats_file_name, output_string, append=T);
}
